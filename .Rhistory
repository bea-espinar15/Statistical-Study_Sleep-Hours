# guardamos las variables como dataframes
df.HS <- data.frame(HS = vec.HS)
df.CS <- data.frame(CS = vec.CS)
# tamaño de la muestra
n <- as.numeric(count(df.HS))
car::qqPlot(vec.HS)
library(readr)
library(dplyr)
library(janitor)
library(ggplot2)
library(fdth)
library(psych)
library(moments)
library(ggrepel)
library(tidyverse)
# PASO 2: Codificamos las funciones que vamos a utilizar
# ------------------------------------------------------
# devuelve un vector con el contenido de un tibble
ObtenerVector <- function(tib) {
for (i in tib)
vec <- i
return(vec)
}
# PASO 3: Traducimos la información del fichero de datos (excel) "sleepdata_2.csv" a dataframe
# --------------------------------------------------------------------------------------------
datos <- read_delim("sleepdata_2.csv",
delim = ";", escape_double = FALSE, na = "NA",
trim_ws = TRUE)
# PASO 4: Nos quedamos con las variables de estudio, eliminando valores nulos
# -----------------------------------------------------------------------------------
# HORAS DE SUEÑO y CALIDAD DEL SUEÑO
# guardamos la variable como tibble
tib.HSyCS <- datos %>% select(3,13) %>% filter(!is.na(3) & !is.na(13))
# pasamos las horas de sueño de segundos a horas
tib.HSyCS$HS <- tib.HSyCS$`Time asleep (seconds)` / 3600
tib.HSyCS <- tib.HSyCS %>% select(1,3)
# pasamos la calidad del sueño de char a numeric (viene en %)
tib.HSyCS$CS <- parse_number(tib.HSyCS$`Sleep Quality`)
tib.HSyCS <- tib.HSyCS %>% select(2,3)
# separamos las variables
tib.HS <- tib.HSyCS[1]
tib.CS <- tib.HSyCS[2]
# guardamos las variables como vectores
vec.HS <- ObtenerVector(tib.HS[1])
vec.CS <- ObtenerVector(tib.CS[1])
# guardamos las variables como dataframes
df.HS <- data.frame(HS = vec.HS)
df.CS <- data.frame(CS = vec.CS)
# tamaño de la muestra
n <- as.numeric(count(df.HS))
tib.HS
df.HS
df.CS
n
hist(vec.HS, breaks = 'Sturges', include.lowest = TRUE, right = FALSE, plot = FALSE)
# creamos los intervalos
intervalos.HS <- hist(vec.HS, breaks = 'Sturges', include.lowest = TRUE, right = FALSE, plot = TRUE)
# creamos los intervalos
intervalos.HS <- hist(vec.HS, breaks = 'Sturges', include.lowest = TRUE, right = FALSE, plot = FALSE)
# creamos los intervalos y calculamos sus f.a.
intervalos.HS <- hist(vec.HS, breaks = 'Sturges', include.lowest = TRUE, right = FALSE, plot = FALSE)
intervalos.HS <- intervalos.HS[1:2]
# metemos los datos en la tabla
# creamos una columna auxiliar para luego añadir las que nos interesan
tabla.freq.HS <- tibble(aux = 1:(length(intervalos.HS[[1]]) - 1))
tabla.freq.HS
intervalos.HS
# generamos los intervalos (las cadenas de caracteres) y las añadimos a la tabla
tabla.freq.HS <- CrearIntervalos(intervalos.HS[[1]], tabla.freq.HS)
tabla.freq.HS
max(vec.HS)
min(vec.HS)
# añadimos las f.a. que obtuvimos a la tabla
tabla.freq.HS <- ObtenerTibbleFA(intervalos.GE[[2]], tabla.freq.HS)
# añadimos las f.a. que obtuvimos a la tabla
tabla.freq.HS <- ObtenerTibbleFA(intervalos.HS[[2]], tabla.freq.HS)
tabla.freq.HS
# eliminamos la columna auxiliar
tabla.freq.HS <- tabla.freq.HS %>% select(2,3)
tabla.freq.HS
# Añade a un tibble una columna con los intervalos indicados
CrearIntervalos <- function(vec, tib) {
interv <- c()
for (i in 1:(length(vec) - 1))
interv <- c(interv, paste('[', vec[i], ', ', vec[i + 1], ')', sep = ''))
# metemos los intervalos en el tibble
tib <- cbind(tib, 'HS' = interv)
return(tib)
}
# mete los datos del vector en una nueva columna del tibble
ObtenerTibbleFA <- function(vec, tib) {
tib <- cbind(tib, 'f.a.' = vec)
return(tib)
}
tabla.freq.HS <- tibble(aux = 1:(length(intervalos.HS[[1]]) - 1))
# generamos los intervalos (las cadenas de caracteres) y las añadimos a la tabla
tabla.freq.HS <- CrearIntervalos(intervalos.HS[[1]], tabla.freq.HS)
# añadimos las f.a. que obtuvimos a la tabla
tabla.freq.HS <- ObtenerTibbleFA(intervalos.HS[[2]], tabla.freq.HS)
# eliminamos la columna auxiliar
tabla.freq.HS <- tabla.freq.HS %>% select(2,3)
#
tabla.freq.HS <- as_tibble(tabla.freq.HS)
tabla.freq.HS <- tibble(aux = 1:(length(intervalos.HS[[1]]) - 1))
# generamos los intervalos (las cadenas de caracteres) y las añadimos a la tabla
tabla.freq.HS <- CrearIntervalos(intervalos.HS[[1]], tabla.freq.HS)
# añadimos las f.a. que obtuvimos a la tabla
tabla.freq.HS <- ObtenerTibbleFA(intervalos.HS[[2]], tabla.freq.HS)
# eliminamos la columna auxiliar
tabla.freq.HS <- tabla.freq.HS %>% select(2,3)
tabla.freq.HS
#
tabla.freq.HS <- as_tibble(tabla.freq.HS)
tabla.freq.HS
View(freq.abs.acc.GE)
library(readr)
library(dplyr)
library(janitor)
library(ggplot2)
library(fdth)
library(psych)
library(moments)
library(ggrepel)
library(tidyverse)
# PASO 2: Codificamos las funciones que vamos a utilizar
# ------------------------------------------------------
# devuelve un vector con el contenido de un tibble
ObtenerVector <- function(tib) {
for (i in tib)
vec <- i
return(vec)
}
# Añade a un tibble una columna con los intervalos indicados
CrearIntervalos <- function(vec, tib) {
interv <- c()
for (i in 1:(length(vec) - 1))
interv <- c(interv, paste('[', vec[i], ', ', vec[i + 1], ')', sep = ''))
# metemos los intervalos en el tibble
tib <- cbind(tib, 'HS' = interv)
return(tib)
}
# mete los datos del vector en una nueva columna del tibble
ObtenerTibbleFA <- function(vec, tib) {
tib <- cbind(tib, 'f.a.' = vec)
return(tib)
}
# calcula las frecuencias relativas
FrecuenciasRelativas <- function(vec_abs) {
rel <- c()
for (i in 1:length(vec_abs))
rel <- c(rel, as.numeric(vec_abs[i] / n))
return(rel)
}
# mete los datos del vector en un tibble que crea
ObtenerTibbleFR <- function(vec, tib) {
tib <- cbind(tib, 'f.r.' = vec)
return(tib)
}
# PASO 3: Traducimos la información del fichero de datos (excel) "sleepdata_2.csv" a dataframe
# --------------------------------------------------------------------------------------------
datos <- read_delim("sleepdata_2.csv",
delim = ";", escape_double = FALSE, na = "NA",
trim_ws = TRUE)
# PASO 4: Nos quedamos con las variables de estudio, eliminando valores nulos
# -----------------------------------------------------------------------------------
# HORAS DE SUEÑO y CALIDAD DEL SUEÑO
# guardamos la variable como tibble
tib.HSyCS <- datos %>% select(3,13) %>% filter(!is.na(3) & !is.na(13))
# pasamos las horas de sueño de segundos a horas
tib.HSyCS$HS <- tib.HSyCS$`Time asleep (seconds)` / 3600
tib.HSyCS <- tib.HSyCS %>% select(1,3)
# pasamos la calidad del sueño de char a numeric (viene en %)
tib.HSyCS$CS <- parse_number(tib.HSyCS$`Sleep Quality`)
tib.HSyCS <- tib.HSyCS %>% select(2,3)
# separamos las variables
tib.HS <- tib.HSyCS[1]
tib.CS <- tib.HSyCS[2]
# guardamos las variables como vectores
vec.HS <- ObtenerVector(tib.HS[1])
vec.CS <- ObtenerVector(tib.CS[1])
# guardamos las variables como dataframes
df.HS <- data.frame(HS = vec.HS)
df.CS <- data.frame(CS = vec.CS)
# tamaño de la muestra
n <- as.numeric(count(df.HS))
# PASO 5: Aplicamos la estadística descriptiva para analizar la variable HS
# -------------------------------------------------------------------------
# 5.1. Calculamos la tabla de frecuencias
# ---------------------------------------
# creamos los intervalos (del tipo '[a,b)') y calculamos sus f.a.
intervalos.HS <- hist(vec.HS, breaks = 'Sturges', include.lowest = TRUE, right = FALSE, plot = FALSE)
intervalos.HS <- intervalos.HS[1:2]
# metemos los datos en la tabla
# creamos una columna auxiliar para luego añadir las que nos interesan
tabla.freq.HS <- tibble(aux = 1:(length(intervalos.HS[[1]]) - 1))
# generamos los intervalos (las cadenas de caracteres) y las añadimos a la tabla
tabla.freq.HS <- CrearIntervalos(intervalos.HS[[1]], tabla.freq.HS)
# añadimos las f.a. que obtuvimos a la tabla
tabla.freq.HS <- ObtenerTibbleFA(intervalos.HS[[2]], tabla.freq.HS)
# eliminamos la columna auxiliar
tabla.freq.HS <- tabla.freq.HS %>% select(2,3)
# pasamos a tibble
tabla.freq.HS <- as_tibble(tabla.freq.HS)
# calculamos f.a.a.
freq.abs.acc.HS <- cumsum(tabla.freq.HS[2])
freq.abs.acc.HS <- rename(freq.abs.acc.HS, f.a.a. = f.a.)
# obtenemos vectores que necesitaremos
vec.fa.HS <- ObtenerVector(tabla.freq.HS[2])
vec.fr.HS <- FrecuenciasRelativas(vec.fa.HS)
# calculamos f.r.
freq.rel.HS <- tibble(aux = 1:(length(intervalos.HS[[1]]) - 1))
freq.rel.HS <- ObtenerTibbleFR(vec.fr.HS, freq.rel.HS)
freq.rel.HS <- freq.rel.HS %>% select(2)
freq.rel.HS <- as_tibble(freq.rel.HS)
# calculamos f.r.a.
freq.rel.acc.HS <- cumsum(freq.rel.HS)
freq.rel.acc.HS <- rename(freq.rel.acc.HS, f.r.a. = f.r.)
# terminamos tabla de frecuencias
tabla.freq.HS <- bind_cols(tabla.freq.HS, freq.abs.acc.HS, freq.rel.HS, freq.rel.acc.HS)
tabla.freq.HS
mean(vec.CS)
mean(vec.HS)
media.HS <-  mean(vec.HS)
# mediana
mediana.HS <- median(vec.HS)
# intervalo modal
max.freq.abs.HS <- max(vec.fa.HS)
interv.modal.HS <- tabla.freq.HS %>% select(1) %>% filter(tabla.freq.HS[2] == max.freq.abs.HS)
interv.modal.HS <- rename(interv.modal.HS, Moda = HS)
media.HS
mediana.HS
interv.modal.HS
perc25.HS <- quantile(vec.HS, probs = 1/4)
# percentil 75%
perc75.HS <- quantile(vec.HS, probs = 3/4)
perc25.HS
perc75.HS
library(readr)
library(dplyr)
library(janitor)
library(ggplot2)
library(fdth)
library(psych)
library(moments)
library(ggrepel)
library(tidyverse)
# PASO 2: Codificamos las funciones que vamos a utilizar
# ------------------------------------------------------
# devuelve un vector con el contenido de un tibble
ObtenerVector <- function(tib) {
for (i in tib)
vec <- i
return(vec)
}
# Añade a un tibble una columna con los intervalos indicados
CrearIntervalos <- function(vec, tib) {
interv <- c()
for (i in 1:(length(vec) - 1))
interv <- c(interv, paste('[', vec[i], ', ', vec[i + 1], ')', sep = ''))
# metemos los intervalos en el tibble
tib <- cbind(tib, 'HS' = interv)
return(tib)
}
# mete los datos del vector en una nueva columna del tibble
ObtenerTibbleFA <- function(vec, tib) {
tib <- cbind(tib, 'f.a.' = vec)
return(tib)
}
# calcula las frecuencias relativas
FrecuenciasRelativas <- function(vec_abs) {
rel <- c()
for (i in 1:length(vec_abs))
rel <- c(rel, as.numeric(vec_abs[i] / n))
return(rel)
}
# mete los datos del vector en un tibble que crea
ObtenerTibbleFR <- function(vec, tib) {
tib <- cbind(tib, 'f.r.' = vec)
return(tib)
}
# calcula la cuasivarianza
CalcularCuasivar <- function(var, n) {
return(var * n / (n - 1))
}
# calcula el coeficiente de variación
CalcularCoefVar <- function(desv.tip, media) {
return(desv.tip / media)
}
# PASO 3: Traducimos la información del fichero de datos (excel) "sleepdata_2.csv" a dataframe
# --------------------------------------------------------------------------------------------
datos <- read_delim("sleepdata_2.csv",
delim = ";", escape_double = FALSE, na = "NA",
trim_ws = TRUE)
# PASO 4: Nos quedamos con las variables de estudio, eliminando valores nulos
# -----------------------------------------------------------------------------------
# HORAS DE SUEÑO y CALIDAD DEL SUEÑO
# guardamos la variable como tibble
tib.HSyCS <- datos %>% select(3,13) %>% filter(!is.na(3) & !is.na(13))
# pasamos las horas de sueño de segundos a horas
tib.HSyCS$HS <- tib.HSyCS$`Time asleep (seconds)` / 3600
tib.HSyCS <- tib.HSyCS %>% select(1,3)
# pasamos la calidad del sueño de char a numeric (viene en %)
tib.HSyCS$CS <- parse_number(tib.HSyCS$`Sleep Quality`)
tib.HSyCS <- tib.HSyCS %>% select(2,3)
# separamos las variables
tib.HS <- tib.HSyCS[1]
tib.CS <- tib.HSyCS[2]
# guardamos las variables como vectores
vec.HS <- ObtenerVector(tib.HS[1])
vec.CS <- ObtenerVector(tib.CS[1])
# guardamos las variables como dataframes
df.HS <- data.frame(HS = vec.HS)
df.CS <- data.frame(CS = vec.CS)
# tamaño de la muestra
n <- as.numeric(count(df.HS))
# PASO 5: Aplicamos la estadística descriptiva para analizar la variable HS
# -------------------------------------------------------------------------
# 5.1. Calculamos la tabla de frecuencias
# ---------------------------------------
# creamos los intervalos (del tipo '[a,b)') y calculamos sus f.a.
intervalos.HS <- hist(vec.HS, breaks = 'Sturges', include.lowest = TRUE, right = FALSE, plot = FALSE)
intervalos.HS <- intervalos.HS[1:2]
# metemos los datos en la tabla
# creamos una columna auxiliar para luego añadir las que nos interesan
tabla.freq.HS <- tibble(aux = 1:(length(intervalos.HS[[1]]) - 1))
# generamos los intervalos (las cadenas de caracteres) y las añadimos a la tabla
tabla.freq.HS <- CrearIntervalos(intervalos.HS[[1]], tabla.freq.HS)
# añadimos las f.a. que obtuvimos a la tabla
tabla.freq.HS <- ObtenerTibbleFA(intervalos.HS[[2]], tabla.freq.HS)
# eliminamos la columna auxiliar
tabla.freq.HS <- tabla.freq.HS %>% select(2,3)
# pasamos a tibble
tabla.freq.HS <- as_tibble(tabla.freq.HS)
# calculamos f.a.a.
freq.abs.acc.HS <- cumsum(tabla.freq.HS[2])
freq.abs.acc.HS <- rename(freq.abs.acc.HS, f.a.a. = f.a.)
# obtenemos vectores que necesitaremos
vec.fa.HS <- ObtenerVector(tabla.freq.HS[2])
vec.fr.HS <- FrecuenciasRelativas(vec.fa.HS)
# calculamos f.r.
freq.rel.HS <- tibble(aux = 1:(length(intervalos.HS[[1]]) - 1))
freq.rel.HS <- ObtenerTibbleFR(vec.fr.HS, freq.rel.HS)
freq.rel.HS <- freq.rel.HS %>% select(2)
freq.rel.HS <- as_tibble(freq.rel.HS)
# calculamos f.r.a.
freq.rel.acc.HS <- cumsum(freq.rel.HS)
freq.rel.acc.HS <- rename(freq.rel.acc.HS, f.r.a. = f.r.)
# terminamos tabla de frecuencias
tabla.freq.HS <- bind_cols(tabla.freq.HS, freq.abs.acc.HS, freq.rel.HS, freq.rel.acc.HS)
# 5.2. Calculamos las medidas de posición para HS
# -----------------------------------------------
# media
media.HS <-  mean(vec.HS)
# mediana (percentil 50%)
mediana.HS <- median(vec.HS)
# intervalo modal
max.freq.abs.HS <- max(vec.fa.HS)
interv.modal.HS <- tabla.freq.HS %>% select(1) %>% filter(tabla.freq.HS[2] == max.freq.abs.HS)
interv.modal.HS <- rename(interv.modal.HS, Moda = HS)
# percentil 25%
perc25.HS <- quantile(vec.HS, probs = 1/4)
# percentil 75%
perc75.HS <- quantile(vec.HS, probs = 3/4)
# 5.3. Calculamos las medidas de dispersión para HS
# -------------------------------------------------
# varianza
var.HS <- var(vec.HS)
# cuasivarianza
cuasivar.HS <- CalcularCuasivar(var.HS, n)
# desviación típica
desv.tip.HS <- sd(vec.HS)
# cuasidesviación típica
cuasidesv.tip.HS <- sqrt(cuasivar.HS)
# coeficiente de variación
coef.var.HS <- CalcularCoefVar(desv.tip.HS, media.HS)
var.HS
desv.tip.HS
sqrt(var.HS)
cuasivar.HS
cuasidesv.tip.HS
coef.cva
coef.var.HS
# coeficiente de asimetría
coef.asim.HS <- skewness(vec.HS)
# coeficiente de kurtosis
coef.kurt.HS <- kurtosis(vec.HS)
coef.asim.HS
coef.kurt.HS
ggplot(df.HS, aes(vec.HS)) +
geom_histogram(color = 1, fill = "#005c00",
breaks = 'Stures') +
geom_freqpoly(data = df.HS, breaks = 'Sturges', color = "red") +
xlab("") +
ylab("") +
ggtitle("Histograma y polígono de frecuencias de las horas de sueño")
ggplot(df.HS, aes(vec.HS)) +
geom_histogram(color = 1, fill = "#005c00") +
geom_freqpoly(data = df.HS, color = "red") +
xlab("") +
ylab("") +
ggtitle("Histograma y polígono de frecuencias de las horas de sueño")
intervla
intervalos.HS
tabla.freq.HS <- tibble(aux = 1:(length(intervalos.HS[[1]]) - 1))
# generamos los intervalos (las cadenas de caracteres) y las añadimos a la tabla
tabla.freq.HS <- CrearIntervalos(intervalos.HS[[1]], tabla.freq.HS)
ta lag.plot()
tabla.freq.HS
interv.HS <- hist(vec.HS, breaks = 'Sturges', include.lowest = TRUE, right = FALSE, plot = FALSE)
interv.HS <- interv.HS[1:2]
# creamos un vector que guarde los intervalos para luego representar la variable
vec.interv.HS <- interv.HS[[1]]
# metemos los datos en la tabla
# creamos una columna auxiliar para luego añadir las que nos interesan
tabla.freq.HS <- tibble(aux = 1:(length(interv.HS[[1]]) - 1))
# generamos los intervalos (las cadenas de caracteres) y las añadimos a la tabla
tabla.freq.HS <- CrearIntervalos(interv.HS[[1]], tabla.freq.HS)
# añadimos las f.a. que obtuvimos a la tabla
tabla.freq.HS <- ObtenerTibbleFA(interv.HS[[2]], tabla.freq.HS)
# eliminamos la columna auxiliar
tabla.freq.HS <- tabla.freq.HS %>% select(2,3)
# pasamos a tibble
tabla.freq.HS <- as_tibble(tabla.freq.HS)
# calculamos f.a.a.
freq.abs.acc.HS <- cumsum(tabla.freq.HS[2])
freq.abs.acc.HS <- rename(freq.abs.acc.HS, f.a.a. = f.a.)
# obtenemos vectores que necesitaremos
vec.fa.HS <- ObtenerVector(tabla.freq.HS[2])
vec.fr.HS <- FrecuenciasRelativas(vec.fa.HS)
# calculamos f.r.
freq.rel.HS <- tibble(aux = 1:(length(interv.HS[[1]]) - 1))
freq.rel.HS <- ObtenerTibbleFR(vec.fr.HS, freq.rel.HS)
freq.rel.HS <- freq.rel.HS %>% select(2)
freq.rel.HS <- as_tibble(freq.rel.HS)
# calculamos f.r.a.
freq.rel.acc.HS <- cumsum(freq.rel.HS)
freq.rel.acc.HS <- rename(freq.rel.acc.HS, f.r.a. = f.r.)
# terminamos tabla de frecuencias
tabla.freq.HS <- bind_cols(tabla.freq.HS, freq.abs.acc.HS, freq.rel.HS, freq.rel.acc.HS)
# 5.2. Calculamos las medidas de posición para HS
# -----------------------------------------------
# media
media.HS <-  mean(vec.HS)
# mediana (percentil 50%)
mediana.HS <- median(vec.HS)
# intervalo modal
max.freq.abs.HS <- max(vec.fa.HS)
interv.modal.HS <- tabla.freq.HS %>% select(1) %>% filter(tabla.freq.HS[2] == max.freq.abs.HS)
interv.modal.HS <- rename(interv.modal.HS, Moda = HS)
# percentil 25%
perc25.HS <- quantile(vec.HS, probs = 1/4)
# percentil 75%
perc75.HS <- quantile(vec.HS, probs = 3/4)
# 5.3. Calculamos las medidas de dispersión para HS
# -------------------------------------------------
# varianza
var.HS <- var(vec.HS)
# cuasivarianza
cuasivar.HS <- CalcularCuasivar(var.HS, n)
# desviación típica
desv.tip.HS <- sd(vec.HS)
# cuasidesviación típica
cuasidesv.tip.HS <- sqrt(cuasivar.HS)
# coeficiente de variación
coef.var.HS <- CalcularCoefVar(desv.tip.HS, media.HS)
# 5.4. Calculamos las medidas de forma para HS
# --------------------------------------------
# coeficiente de asimetría
coef.asim.HS <- skewness(vec.HS)
# coeficiente de kurtosis
coef.kurt.HS <- kurtosis(vec.HS)
vec.interv.HS
ggplot(df.HS, aes(vec.HS)) +
geom_histogram(color = 1, fill = "#005c00", breaks = vec.interv.HS) +
geom_freqpoly(data = df.HS, color = "red", breaks = vec.interv.HS) +
xlab("") +
ylab("") +
ggtitle("Histograma y polígono de frecuencias de las horas de sueño")
ggplot(df.HS, aes(vec.HS)) +
geom_histogram(color = 1, fill = "#005c00", breaks = vec.interv.HS) +
geom_freqpoly(data = df.HS, color = "#71c55b", breaks = vec.interv.HS) +
xlab("") +
ylab("") +
ggtitle("Histograma y polígono de frecuencias de las horas de sueño")
tabla.freq.HS
ggplot(df.HS, aes(vec.HS)) +
geom_histogram(color = 1, fill = "#005c00", breaks = vec.interv.HS) +
geom_freqpoly(data = df.HS, color = "#71c55b", breaks = vec.interv.HS) +
xlab("") +
ylab("") +
ggtitle("Histograma y polígono de frecuencias de las horas de sueño") +
ylim(c(0,400)) +
xlim(c(0, 13))
ggplot(df.HS, aes(vec.HS)) +
geom_step(stat = "ecdf", color = "#71c55b", lwd = 1) +
xlab("") +
ylab("") +
ggtitle("Polígono de frecuencias f.r.a.")
hist.HS <- ggplot(df.HS, aes(vec.HS)) +
geom_histogram(color = 1, fill = "#005c00", breaks = vec.interv.HS) +
geom_freqpoly(data = df.HS, color = "#71c55b", breaks = vec.interv.HS) +
xlab("") +
ylab("") +
ggtitle("Histograma y polígono de frecuencias de las horas de sueño") +
ylim(c(0,400)) +
xlim(c(0, 13))
# polígono de frecuencias (f.r.a)
pol.fra.HS = ggplot(df.HS, aes(vec.HS)) +
geom_step(stat = "ecdf", color = "#71c55b", lwd = 1) +
xlab("") +
ylab("") +
ggtitle("Polígono de frecuencias f.r.a.")
